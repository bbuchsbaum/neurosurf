% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighborhood.R
\name{smooth,SurfaceGeometry-method}
\alias{smooth,SurfaceGeometry-method}
\title{Smooth a Brain Surface Geometry}
\usage{
\S4method{smooth}{SurfaceGeometry}(
  x,
  type = c("taubin", "laplace", "HClaplace", "fujiLaplace", "angWeight",
    "surfPreserveLaplace"),
  lambda = 0.7,
  mu = -0.53,
  delta = 0.1,
  iteration = 5
)
}
\arguments{
\item{x}{A \code{\linkS4class{SurfaceGeometry}} object representing the brain surface to be smoothed.}

\item{type}{A character string specifying the smoothing algorithm to use. Available options are:
\describe{
  \item{"taubin"}{Applies Taubin smoothing, which preserves the overall shape of the surface while reducing noise.}
  \item{"laplace"}{Performs Laplacian smoothing, which is a basic smoothing method that averages the position of each vertex with its neighbors.}
  \item{"HClaplace"}{Applies a Laplacian smoothing with hard constraints. It preserves the boundary vertices and is useful for surfaces with important edge features.}
  \item{"fujiLaplace"}{Uses a Laplacian smoothing method that preserves features more aggressively than the basic Laplacian method.}
  \item{"angWeight"}{Performs angle-weighted smoothing, which considers the angles between faces to preserve sharp features.}
  \item{"surfPreserveLaplace"}{Applies surface-preserving Laplacian smoothing, aiming to maintain the original surface's key characteristics while smoothing.}
}}

\item{lambda}{A numeric value that controls the amount of smoothing. Higher values lead to more aggressive smoothing. This parameter is particularly relevant for Taubin and Laplacian smoothing methods.}

\item{mu}{A numeric value used in Taubin smoothing to control shrinkage. A value close to zero reduces shrinkage, while a negative value can help in shape preservation.}

\item{delta}{A numeric value used in certain smoothing algorithms to adjust the influence of smoothing (e.g., in surface-preserving methods).}

\item{iteration}{An integer specifying the number of smoothing iterations to apply. More iterations result in a smoother surface but can also lead to excessive flattening.}
}
\value{
The function returns the smoothed \code{SurfaceGeometry} object with the updated mesh.
}
\description{
This method applies smoothing to a brain surface geometry object of class \code{SurfaceGeometry} using various algorithms. Smoothing is useful for removing noise and creating a more continuous surface.
}
\examples{
\dontrun{
  # Example of applying Taubin smoothing to a brain surface
  smoothed_surface <- smooth(white_surf, type="taubin", lambda=0.5, mu=-0.5, iteration=10)

  # Example of using surface-preserving Laplacian smoothing
  smoothed_surface <- smooth(white_surf, type="surfPreserveLaplace", iteration=5)
}

}
\seealso{
\code{\link[Rvcg]{vcgSmooth}} for more details on the underlying smoothing algorithms.
}
